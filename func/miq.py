from PIL import Image, ImageDraw, ImageFont
import io
from io import BytesIO
import textwrap
from func.log import get_log

def wrap_text_by_pixel(draw: ImageDraw.ImageDraw, text: str, font: ImageFont.ImageFont, max_pixel_width: int) -> str:
    """
    テキストをピクセル幅に基づいて改行する関数
    """
    words = text.split()
    lines = []
    line = ""

    for word in words:
        test_line = line + (" " if line else "") + word
        if draw.textlength(test_line, font=font) <= max_pixel_width:
            line = test_line
        else:
            lines.append(line)
            line = word
    if line:
        lines.append(line)

    return "\n".join(lines)

def draw_centered_multiline(draw, text_lines, font, area_left, area_right, start_y, fill, line_spacing=5):
    """
    各行を中央揃えで描画する関数
    """
    area_width = area_right - area_left
    y = start_y
    for line in text_lines:
        line_width = draw.textlength(line, font=font)
        x = area_left + (area_width - line_width) // 2
        draw.text((x, y), line, font=font, fill=fill)
        y += font.size + line_spacing

def create_quote_image(icon: BytesIO, content:str, author:str, color:bool = None) -> BytesIO:
    """
    Make it a Quoteを作成します。
    Generated by Microsoft Copilot
    Args:
        icon (BytesIO): アイコン
        content (str): 内容
        author (str): 著者
        color (:obj:`bool`, optional): カラーかモノクロか
    Returns:
        BytesIO: 画像のデータ
    """
    width, height = 800, 400
    log = get_log("miq.create_quote_image")

    img = Image.new("RGB", (width, height), color=(0, 0, 0))
    draw = ImageDraw.Draw(img)

    icon = Image.open(icon)

    if not color:
        icon = icon.convert("L").convert("RGB")
    else:
        icon = icon.convert("RGB")

    icon_ratio = icon.width / icon.height
    new_height = height
    new_width = int(new_height * icon_ratio)
    resized_icon = icon.resize((new_width, new_height))

    icon_canvas = Image.new("RGB", (height, height), color=(255, 255, 255))
    offset_x = (height - new_width) // 2 if new_width < height else 0
    offset_y = (height - new_height) // 2 if new_height < height else 0
    icon_canvas.paste(resized_icon, (offset_x, offset_y))

    img.paste(icon_canvas, (0, 0))

    grad_width = 200
    gradient = Image.new("L", (grad_width, height), color=0)
    for x in range(grad_width):
        alpha = int(255 * (x / grad_width))
        for y in range(height):
            gradient.putpixel((x,y), alpha)
    black_area = Image.new("RGB", (grad_width, height), color=(0, 0, 0))
    img.paste(black_area, (height, 0), mask=gradient)

    font_quote = ImageFont.truetype("font/miq_n.ttf", 28)
    font_author = ImageFont.truetype("font/miq_n.ttf", 20)
    font_signature = ImageFont.truetype("font/miq_s.ttf", 15)

    max_text_width = width - height - 40
    wrapped_quote = wrap_text_by_pixel(draw, content, font_quote, max_text_width)
    quote_lines = wrapped_quote.split("\n")
    log.debug(wrapped_quote)

    total_text_height = len(quote_lines) * (font_quote.size + 5)
    start_y = (height - total_text_height) // 2 - 20

    draw_centered_multiline(
        draw,
        quote_lines,
        font_quote,
        area_left=height,
        area_right=width,
        start_y=start_y,
        fill=(255, 255, 255),
        line_spacing=5
    )

    wrapped_author = wrap_text_by_pixel(draw, author, font_author, max_text_width)
    author_lines = wrapped_author.split("\n")

    total_author_height = len(author_lines) * (font_author.size + 5)
    start_y_author = start_y + total_text_height + 10

    draw_centered_multiline(
        draw,
        author_lines,
        font_author,
        area_left=height,
        area_right=width,
        start_y=start_y_author,
        fill=(200, 200, 200),
        line_spacing=5
    )

    signature = "NyaXBot@1340"
    bbox_sig = draw.textbbox((0, 0), signature, font=font_signature)
    sig_w = bbox_sig[2] - bbox_sig[0]
    sig_h = bbox_sig[3] - bbox_sig[1]
    pos_sig = (
        width - sig_w - 10,
        height - sig_h -10
    )
    draw.text(pos_sig, signature, font=font_signature, fill=(150, 150, 150))

    output = BytesIO()
    img.save(output, format="JPEG", quality=85)
    output.seek(0)

    return output
